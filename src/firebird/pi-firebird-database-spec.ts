import { PiFirebirdDatabase } from "./pi-firebird-database";
import * as FB from 'node-firebird';
import { PiQueryType, PiQueryTypeStr, PiDatabase } from "../base/pi-database";
import { PiFirebirdPool } from './pi-firebird-pool';

/*
var
    queryResponse: any[];

class MockDB implements FB.Database, FB.Transaction {
    commit(callback: FB.SimpleCallback) { callback(null) }
    rollback(callback: FB.SimpleCallback) { callback(null) }
    detach(callback: FB.SimpleCallback): FB.Database { callback(null); return this; }
    transaction(isolation: FB.Isolation, callback: FB.TransactionCallback): FB.Database {
        if (isolation instanceof Function)
            callback = isolation as any;
        callback(null, new MockDB());
        return this;
    }
    query(query: string, params: any[], callback: FB.QueryCallback): FB.Database {
        callback(null, queryResponse);
        return this;
    }
    // TODO
    execute(query: string, params: any[], callback: FB.QueryCallback): FB.Database { return this; };
    sequentially(query: string, params: any[], rowCallback: FB.SequentialCallback, callback: FB.SimpleCallback): FB.Database {
        return this;
    };
    drop(callback: FB.SimpleCallback): void { callback(null); }
    escape(value: any): string { return 'x'; }
}
*/

describe('PiFirebirdDatabase', () => {
    let pool: PiFirebirdPool;
    let db: PiDatabase;
    // let mockdb: MockDB | any;

    beforeEach(() => {
        pool = new PiFirebirdPool({
            database: '/firebird/data/test/test01.fdb',
            host: '127.0.0.1',
            user: 'sysdba',
            password: 'masterkey',
            port: 3050
        }, 4);
    });

    describe('open/close', () => {
        it('should get a connection from pool and release it', async () => {
            db = await pool.get();
            await db.close();
        });
    });

    describe('Database operations without transaction', () => {
        beforeEach(async () => db = await pool.get());
        afterEach(() => db.close());

        test(PiQueryType.any, `
            recreate table spec$test(
                id int generated by default as identity not null primary key, 
                dummy varchar(10)
            )`, [], undefined);
        test(PiQueryType.insert, 'insert into spec$test(dummy) values (:values) returning id', { values: ['x'] }, [{ id: 1 }]);
        // test(PiQueryType.select, 'select count(*) qtd_rows from spec$test', [], { rows: [{ qtd_rows: 1 }] });
        // test(PiQueryType.update, 'update spec$test set dummy = ? where id = 1', ['y'], undefined);
        // test(PiQueryType.select, 'select * from spec$test', [], { rows: [{ id: 1, dummy: 'y' }] });
        // test(PiQueryType.delete, 'delete from spec$test where id = ?', [1], undefined);
        // test(PiQueryType.any, 'drop table spec$test', [1], undefined);
    });

    // xdescribe('Database operations with commited transaction', () => {
    //     beforeEach(async () => db = await pool.get());
    //     afterEach(() => db.close());
    //     test(PiQueryType.any, `
    //         recreate table spec$test(
    //             id int generated by default as identity not null primary key, 
    //             dummy varchar(10)
    //         )`, [], undefined, true);
    //     test(PiQueryType.insert, 'insert into spec$test(dummy) values (?)', ['x'], undefined, true);
    //     test(PiQueryType.select, 'select count(*) qtd_rows from spec$test', [], { rows: [{ qtd_rows: 1 }] }, true);
    //     test(PiQueryType.update, 'update spec$test set dummy = ? where id = 1', ['y'], undefined, false);
    //     test(PiQueryType.select, 'select * from spec$test', [], { rows: [{ id: 1, dummy: 'x' }] }, true);
    //     test(PiQueryType.delete, 'delete from spec$test where id = ?', [1], undefined, true);
    //     test(PiQueryType.any, 'drop table spec$test', [1], undefined);
    // });

    function test(type: PiQueryType, sql: string, params: any, expected: any, doCommit?: boolean) {
        it('should execute ' + PiQueryTypeStr[type], async () => {
            let intf = (db as any)._db;
            if (doCommit !== undefined) {
                spyOn(intf, 'transaction').and.callThrough();
                await db.beginTransaction();
                expect(intf.transaction).toHaveBeenCalled();
                intf = (db as any)._currTransac;
            }

            spyOn(intf, 'query').and.callThrough();

            const result = await db.query(sql, params);

            expect(intf.query).toHaveBeenCalled();
            expect(result).toEqual(expected);

            if (doCommit === true) {
                spyOn(intf, 'commit').and.callThrough();
                await db.commit();
                expect(intf.commit).toHaveBeenCalled();
            }
            else if (doCommit === false) {
                spyOn(intf, 'rollback').and.callThrough();
                await db.rollback();
                expect(intf.rollback).toHaveBeenCalled();
            }
        });
    }
})