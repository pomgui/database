import { PiFirebirdDatabase } from "./pi-firebird-database";
import * as FB from 'node-firebird';
import { DatabaseCallback } from "node-firebird";
import { PiQueryType, PiQueryTypeStr } from "../base/pi-database";

var
    queryResponse: any[];

class MockDB implements FB.Database, FB.Transaction {
    commit(callback: FB.SimpleCallback) { callback(null) }
    rollback(callback: FB.SimpleCallback) { callback(null) }
    detach(callback: FB.SimpleCallback) { callback(null) }
    transaction(isolation: FB.Isolation, callback: FB.TransactionCallback) {
        if (isolation instanceof Function)
            callback = isolation as any;
        callback(null, new MockDB())
    }
    query(query: string, params: any[], callback: FB.QueryCallback) { callback(null, queryResponse) }
    // TODO
    execute(query: string, params: any[], callback: FB.QueryCallback): void { };
    sequentially(query: string, params: any[], rowCallback: FB.SequentialCallback, callback: FB.SimpleCallback): void { };
    getInfoSql(request: any[], callback: FB.QueryCallback): void {}
}

describe('PiFirebirdDatabase', () => {
    let db: PiFirebirdDatabase;
    let mockdb: MockDB | any;

    beforeEach(() => {
        db = new PiFirebirdDatabase({
            database: '/firebird/data/test/test01.fdb',
            host: '127.0.0.1',
            user: 'sysdba',
            password: 'masterkey',
            port: 3050
        }, 4);
        const pool = (db as any)._pool;
        spyOn(pool, 'get').and.callFake((cb: DatabaseCallback) => cb(null, mockdb = new MockDB()));
});

    describe('open/close', () => {
        it('should get a connection from pool and release it', async () => {
            const pool = (db as any)._pool;
            await db.open();
            expect(pool.get).toHaveBeenCalled();
            expect((db as any)._isOpen).toBeTrue();

            spyOn(mockdb, 'detach').and.callThrough();
            await db.close();
            expect(mockdb.detach).toHaveBeenCalled();
            expect((db as any)._isOpen).toBeFalse();
        });
    });

    describe('Database operations without transaction', () => {
        beforeEach(() => db.open());
        afterEach(() => db.close());

        test(PiQueryType.any, `
            recreate table spec$test(
                id int generated by default as identity not null primary key, 
                dummy varchar(10)
            )`, [], undefined);
        test(PiQueryType.insert, 'insert into spec$test(dummy) values (?) returning id', ['x'], { rows: [{ id: 1 }] });
        test(PiQueryType.select, 'select count(*) qtd_rows from spec$test', [], { rows: [{ qtd_rows: 1 }] });
        test(PiQueryType.update, 'update spec$test set dummy = ? where id = 1', ['y'], undefined);
        test(PiQueryType.select, 'select * from spec$test', [], { rows: [{ id: 1, dummy: 'y' }] });
        test(PiQueryType.delete, 'delete from spec$test where id = ?', [1], undefined);
        test(PiQueryType.any, 'drop table spec$test', [1], undefined);
    });

    describe('Database operations with commited transaction', () => {
        beforeEach(() => db.open());
        afterEach(() => db.close());

        test(PiQueryType.any, `
            recreate table spec$test(
                id int generated by default as identity not null primary key, 
                dummy varchar(10)
            )`, [], undefined, true);
        test(PiQueryType.insert, 'insert into spec$test(dummy) values (?)', ['x'], undefined, true);
        test(PiQueryType.select, 'select count(*) qtd_rows from spec$test', [], { rows: [{ qtd_rows: 1 }] }, true);
        test(PiQueryType.update, 'update spec$test set dummy = ? where id = 1', ['y'], undefined, false);
        test(PiQueryType.select, 'select * from spec$test', [], { rows: [{ id: 1, dummy: 'x' }] }, true);
        test(PiQueryType.delete, 'delete from spec$test where id = ?', [1], undefined, true);
        test(PiQueryType.any, 'drop table spec$test', [1], undefined);
    });

    function test(type: PiQueryType, sql: string, params: any[], expected: any, doCommit?: boolean) {
        it('should execute ' + PiQueryTypeStr[type], async () => {
            let intf = mockdb;
            if (doCommit !== undefined) {
                spyOn(intf, 'transaction').and.callThrough();
                await db.beginTransaction();
                expect(intf.transaction).toHaveBeenCalled();
                intf = mockdb.currTransac;
            }

            queryResponse = expected && expected.rows;
            if (type == PiQueryType.insert && queryResponse) queryResponse = queryResponse[0];
            spyOn(intf, 'query').and.callThrough();

            const result = await (db as any)._executeQuery(type, sql, params);

            expect(intf.query).toHaveBeenCalled();
            expect(result).toEqual(expected);

            if (doCommit === true) {
                spyOn(intf, 'commit').and.callThrough();
                await db.commit();
                expect(intf.commit).toHaveBeenCalled();
            }
            else if (doCommit === false) {
                spyOn(intf, 'rollback').and.callThrough();
                await db.rollback();
                expect(intf.rollback).toHaveBeenCalled();
            }
        });
    }
})